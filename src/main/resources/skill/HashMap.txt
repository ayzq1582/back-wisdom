数据结构
	数组+链表+红黑树（1.8）
	根据hash存储到数组上，如何hash值相等通过链表储存

红黑树
    原则：max<=2*main
    平衡二叉树是最好的存储方式，但是旋转消耗性能，红黑树采用一个折中的做法

DOS（拒绝服务）
    攻击原则正是利用相同hash值链表存储的结构，请求存储大量相同hash值但是不相同的key,这样查询会消耗大量的cup资源，导致doc


算法
    重写的hash
        static final int hash(Object key) {
            int h;
            return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
        }

    扩容因子0.75
        为1的话空间利用率很高，提高查询成本（链表的几率大）
        为0.5的话空间利用率低下

    TREEIFY_THRESHOLD =8（树化参数：链表最大长度转红黑树）
        根据泊松分布推算，出现概率为万分之6



PUT
    初始化map,判断key的hash冲突
        无冲突插入数组
        有冲突判断是相等
            不等插入数组
            相等插入链表，判断是否满足传换红核数条件